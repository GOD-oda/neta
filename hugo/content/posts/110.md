---
title: Mockeryを追いかけてみた
date: 2022-08-28T08:52:18+09:00
publishDate: 2022-08-28T08:52:18+09:00
draft: false
tags: [php,mockery]
categories: [a]
author: GOD oda
ogImage: "/images/ogImage/110.png"
---


{{<iframe href="https://github.com/mockery/mockery" if-url="//iframely.net/Uc0Tscz">}}


# サンプルコード
下記のように書かれたコードを追いかけるとする

```php
<?php

class Test extends TestCase 
{
  public function testFoo()
  {
    \Mockery::mock(FooInterface::class)
  }
}
```

# 処理の流れ
## 1. \Mockery::mock()で始める
モックを作る起点であり、`call_user_func_array`でモックしたクラスを管理するコンテナに対して`mock()`をコールする

1. `self::getContainer()`で`\Mockery\Container`を取得
2. `\Mockery\Container::mock()`をコール

## 2. \Mockery::getContainer()でコンテナ取得
1. `$self::_container`がnullなら`\Mockery\Container`を生成しセットする
2. `\Mockery\Container`はジェネレータ(`\Mockery\Generator\Generator`)とローダー(`\Mockery\Loader\Loader`)に依存する

ジェネレータとローダーはインターフェースなのでデフォルトではそれらを実装した下記クラスがセットされる

- `\Mockery::getGenerator()→getDefaultGenerator()`で取得される`\Mockery\Generator\CachingGenerator`
- `\Mockery::getLoader()->getDefaultLoader()`で取得される`\Mockery\Loader\EvalLoader`



`\Mockery\Generator\CachingGenerator`は`\Mockery\Generator\StringManipulationGenerator`に依存し、後で使うことになる


# 3. \Mockery\Container::mock()の処理
ここが実際にモックを作っている処理の全てになる

大きく分けると次のようになる
- TODO

一旦[L119](https://github.com/mockery/mockery/blob/master/library/Mockery/Container.php#L119)まで飛ばす

1. `\Mockery\Generator\MockConfigurationBuilder`のインスタンスを生成する
2. `setParameterOverrides()`に`\Mockery\Mockery::getConfigration()→getInternalClassMethodParamMaps()`で取得した配列を渡す（デフォルトは空）
3. `setParameterOverrides()`に`\Mockery\Mockery::getConfiguration()->getConstantsMap()`で取得した配列を渡す（デフォルトは空）
4. `array_shift`で`\Mockery\Container::mock()`に渡した引数を1つずつstringかobjectかarrayかそれ以外で処理する（それ以外の場合は例外が投げられる）
5. サンプルでは文字列として処理される

### 文字列での処理
`|`で分割してるから複数まとめて指定できるのかな？

条件分岐は以下の通り
```php
if ($arg === 'null') {
} elseif (strpos($type, ',') && !strpos($type, ']')) {
} elseif (substr($type, 0, 6) == 'alias:') {
} elseif (substr($type, 0, 9) == 'overload:') {
} elseif (substr($type, strlen($type)-1, 1) == ']') {
} elseif (class_exists($type, true) || interface_exists($type, true) || trait_exists($type, true)) {
} elseif (!\Mockery::getConfiguration()->mockingNonExistentMethodsAllowed() && (!class_exists($type, true) && !interface_exists($type, true))) {
    throw new \Mockery\Exception("Mockery can't find '$type' so can't mock it");
} else {
    if (!$this->isValidClassName($type)) {
        throw new \Mockery\Exception('Class name contains invalid characters');
    }
    $builder->addTarget($type);
}
```
サンプルコードはInterfaceなので`interface_exists($type, true)`が真となり、`addTarget()`が呼ばれ`\Mockery\Generator\MockConfigurationBuilder::$targets`に追加される

6. `\Mockery\Generator\MockConfigurationBuilder::addBlackListedMethods($blocks)`が呼ばれる（デフォルトは空配列）
7. `\Mockery\GeneratorMockConfigurationBuilder::$blackListedMethods`に`__consturct()`を入れるか分岐する（入れない場合は`\Mockery\Generator\MockConfigurationBuilder::mockOriginalDestructor`に`true`がセットされる）
8. `\Mockery\Generator\MockConfigurationBuilder::getConfigration()`で`\Mocker\Generator\MockConfigration`のインスタンスを生成する

今までで`\Mockery\Generator\MockConfigurationBuilder`にセットしたものを利用している

9. `\Mockery\Container::getGenerator()->generate($config)`を使いクラス定義のコードを文字列で生成している

この記事の`テンプレートの書き換え`がまさにこの処理

https://toyo.hatenablog.jp/entry/2020/08/10/151148

書き換えが行われる処理は各クラスに実装されている

|クラス|処理内容|
|---|---|
|`Mockery\Generator\StringManipulation\Pass\ClassNamePass`|名前空間とクラス名の置換|
|TODO||

10. 書き換えが完了したら`\Mockery\Container::getLoader()->load($def)`（`$def`は`generate()`の戻り値）でクラスのロードを行う


# 参考
- https://github.com/mockery/mockery
- https://www.php.net/manual/ja/function.call-user-func-array.php
